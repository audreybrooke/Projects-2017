Answer to Homework 6 Question 2 Part c

Runtime of mergesort as a function of k and n
   mergesort calls mSort which creates an array of
   2*k indices -> O(k). Then calls mSort k times (on each
   subset). Then, merge is called. merge, for each spot in
   the area being merged (max n), iterates through the k sections
   and finds the smallest element and puts it in the temp
   array -> (O(k * n)). The temp array is copied back into
   myArray -> O(n). Thus, merge takes O(k*n). So mSort's 
   recurrance relation is T(n) = kT(n/k) + O(k*n). So, the 
   recurrsive tree is log base k depth because the amount of
   elements to be sorted is divided by k each time. There
   are n total elements at each depth of the tree and the single
   call to merge takes O(n*k). Sum of this recurrance is
   n * log base k of (n*k).
   

Runtime when k=n
   When k=n there is an individual subgroup made for each
   value of myArray, thus mSort immediately breaks the array
   into ints individual parts, so merge has to sort all elements
   at once by comparing them against eachother, finding the
   smallest, putting it in a new array and finding the next
   smallest compared to the rest of the elements. This resembles
   selection sort (the algorithm finds the smallest element out
   of remaining options and puts it in its correct place).
   selection sort and this case have the runtime O(n^2).