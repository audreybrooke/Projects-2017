Audrey Brooke
Answers to Problems 2, 3, 6


Problem 2
---------
 1. list of strings representing the history
      Would use a list because the order of the subjects
      matters since they are organized by their number.
      
 2. set containing strings of student names
      Would use a set because the order does not matter,
      and the user does not need to retrieve the student's
      in set, just know weather or not they are in the set.
      
 3. map with student names as keys and student structs as values
      Would use a map because the order does not matter,
      but it needs to be able to return the struct. A set
      could not return the object.
      
 4. list of student structs that contain the grade (string)
    and name (string)
      Would use list because it allows itteration through
      the student structs and can check at each one if the
      student grade matches the given grade.
      Can not use map because can not itterate through a map
      and the grade can not be used as a key because students
      must have individual keys. So giving a grade as key would
      not work if 2 people have the same grade.
      Can not be set because if the set contains all students
      it would just say if a student was in the class or not
      and could not return the object to check that student's
      grade.
      
      
Problem 3
---------

Part (a)
The runtime would be theta(n^2). This is because the first loop
will execute n times (since it runs from 0 to n) and in the worst
case, every value will be 0 so the if statement will be true each
time. Then, the second for loop runs a max of n times (because i
is n at max). Once in the next if statement the calculations run
in constant
time because j starts at 0, causing the third loop to run do 
A[i] = 1 one time. After this, the if statement in the "j"/second
for loop will always evaluate to false. So the third loop will
only execute once per iteration of the first loop, and when it
does it only does one operation. The second loop will execute a
maximum of i times but only during the first itteration through
can the if statement be true.

Part (b)
Since i in the first for loop is multiplied by 2 each itteration,
the sequence of numbers entering the function call is 1, 2, 4, 8,
16, 32, ..., n. Once sent to the function, it is recursively
called the number of times of the parameter (because the
parameter is subtracted by 1 until it is equal to 1). Thus, the
problem does the summation of 1, 2, 4, 8, ..., n operations.
This summation is: the summation from i=1 until logbase2n of 2^i.
This summation caculates to 2(n-1) which is theta(n).

Part (c)
This code has a runtime theta(n^2 * logn). The first loop is
theta(n), which is added to the runtime of the code after that
loop ends. The next for loop (first of the nested loops) runs
n times because i goes from 0 to n. The while loop nested in
in there evaluates to n*log n. This is because the if statement
will evaluate true everytime for i=1, n/2 the times for i=2,
n/3 times for i=3, etc. When the if statement is true, n
calculations are done in the for loop. Thus the while is n* the
summation of 1 + 1/2 + 1/3 + 1/4 + ... + 1/n. That summation is
harmonic and equal to logn. Thus the while loop is n*logn and
that is inside a for loop that executes n times, so the runtime
of the whole section is n^2logn + n (from the first separate
loop). This is theta (n^2 * logn).

Part (d)
In this loop, making a[i] = sqrt(i) is constant time unless,
the if statement (i == size) is true. Since the array triples
in size each time this is true. It will be true at i=3,9,27,...,n
All the operations in this if are constant time, except the for
loop which executes size times. So the runtime is the summation
of the sizes that make the if statement true. This is the
summation from i=1 to logbase3n of 3^i. This evaluates to 
3(n-1)/2 which is theta(n).
      

Problem 6
---------

Part (a)
The begining of the list is the bottom of the stack and the end
of the list is the top of the stack

pushback (1)
   stack1: 1
   stack2:
pushback (2)
   stack1: 1, 2
   stack2:
popfront ()
   stack1:
   stack2: 2
pushfront (3)
   stack1:
   stack2: 2, 3
pushfront (4)
   stack1:
   stack2: 2, 3, 4
popback ()
   stack1: 4, 3
   stack2:
pushfront (5)
   stack1: 4, 3
   stack2: 5
pushback (6)
   stack1: 4, 3, 6
   stack2: 5

Part (b)

For a deque with n elements, the worst case runtime of 
pushback(x) and pushfront(x) is theta (1). This is because
no matter what, these functions just add an element to a stack
which is a constant run time (if the stacks are implemented as
linked lists) since it takes the same number of operations to
move the head / tail pointer and update the previous head / tail
pointer. If the stacks were implemented as arrays, the worst case
run time for these functions would be n in the case that the
array had reached capacity and every index had to be coppied
over to a larger array.

popfront () and popback() have a worst case run time of theta
(n). This is the case, because the worst case scenario is when
the stack to be popped from (stack1 for popfront() and stack2 for
popback()) is empty. In that case, the entire contents of the
deque is in the other stack. Thus that stack has size n. Next,
that whole stack is popped and pushed on the other stack. This
would take 2n operations and popping the last item off the newly
filled stack would take 1 operation. Thus, these functions take
2n+1 operations in the worst case, which is just theta (n).

Part (c)
The amortized runtime of popback() (if there is no popfront())
is theta (1). Using the credit scheme way of solving, if there
are 2 operations counted each time the user uses pushfront(x),
then if they popback() and stack1 is empty the entire contents
of stack2 is copied over. This will only happen once for each
item pushed to stack2 because popfront() can not be called
(which would potentially move them back to stack2). Thus, when
the item is originally 
added to stack2 it uses 1 operation and when it is inevitably
copied over to stack1 (which will happen only once) it uses the
second operation. The same logic applies to popback() and moving
items from stack2 to stack1. So the amortized runtime would also
be constant.
The push functions (pushfront(x) and pushback(x)) will have a
constant runtime, as well. If the deque is implemented with a 
linked list then each push will cause a change in a set number
of pointers reguardless of the size of the deque. If the deque
is implemented as an array the amortized runtime would also be
constant because the credit scheme says that when the item is
added it is counted with 2 extra operations and if the array
reaches capacity and needs to be copied over the two "credits"
are used to copy the array over. It needs two because it must
copy the first part of the array which is of equal size, as well.

Part (d)
Calling popfront() then popback() repeatedly once one of the
stacks is empty would create a very poor amortized runtime
because once one of the stacks is empty and the corresponding pop
is called, the entire concents of the other stack must be
transfered over. When that happens, the second stack is now empty
so calling the original pop again will cause the entire stack to
be coppied back over to the first stack. This process of copying
the stack just to pop
one item will continue until the deque is empty and as long as
popback() and popfront() are called one after another, then the
entire deque will need to be coppied from one stack to another.


     
