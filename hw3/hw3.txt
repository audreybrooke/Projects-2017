Audrey Brooke
Answers to Problems 2, 3, 6


Problem 2
---------
 1. list of strings representing the history
      Would use a list because the order of the subjects
      matters since they are organized by their number.
      
 2. set containing strings of student names
      Would use a set because the order does not matter,
      and the user does not need to retrieve the student's
      in set, just know weather or not they are in the set.
      
 3. map with student names as keys and student structs as values
      Would use a map because the order does not matter,
      but it needs to be able to return the struct. A set
      could not return the object.
      
 4. list of student structs that contain the grade (string)
    and name (string)
      Would use list because it allows itteration through
      the student structs and can check at each one if the
      student grade matches the given grade.
      Can not use map because can not itterate through a map
      and the grade can not be used as a key because students
      must have individual keys. So giving a grade as key would
      not work if 2 people have the same grade.
      Can not be set because if the set contains all students
      it would just say if a student was in the class or not
      and could not return the object to check that student's
      grade.
      
      
Problem 3
---------

Part (a)

Part (b)

Part (c)

Part (d)
      

Problem 6
---------

Part (a)
The begining of the list is the bottom of the stack and the end
of the list is the top of the stack

pushback (1)
   stack1: 1
   stack2:
pushback (2)
   stack1: 1, 2
   stack2:
popfront ()
   stack1:
   stack2: 2
pushfront (3)
   stack1:
   stack2: 2, 3
pushfront (4)
   stack1:
   stack2: 2, 3, 4
popback ()
   stack1: 4, 3
   stack2:
pushfront (5)
   stack1: 4, 3
   stack2: 5
pushback (6)
   stack1: 4, 3, 6
   stack2: 5

Part (b)

For a deque with n elements, the worst case runtime of 
pushback(x) and pushfront(x) is theta (1). This is because
no matter what, these functions just add an element to a stack
which is a constant run time (if the stacks are implemented as
linked lists) since it takes the same number of operations to
move the head / tail pointer and update the previous head / tail
pointer. If the stacks were implemented as arrays, the worst case
run time for these functions would be n in the case that the
array had reached capacity and every index had to be coppied
over to a larger array.

popfront () and popback() have a worst case run time of theta
(n). This is the case, because the worst case scenario is when
the stack to be popped from (stack1 for popfront() and stack2 for
popback()) is empty. In that case, the entire contents of the
deque is in the other stack. Thus that stack has size n. Next,
that whole stack is popped and pushed on the other stack. This
would take 2n operations and popping the last item off the newly
filled stack would take 1 operation. Thus, these functions take
2n+1 operations in the worst case, which is just theta (n).

Part (c)
The amortized runtime of popback() (if there is no popfront())
is theta (1). Using the credit scheme way of solving, if there
are 2 operations counted each time the user uses pushfront(x),
then if they popback() and stack1 is empty the entire contents
of stack2 is copied over. Thus, when the item is originally 
added to stack2 it uses 1 operation and when it is inevitably
copied over to stack1 (which will happen only once) it uses the
second operation. The same logic applies to popback() and moving
items from stack2 to stack1. So the amortized runtime would also
be constant.

Part (d)
Calling popfront() then popback() repeatedly once one of the
stacks is empty would create a very poor amortized runtime
because once one of the stacks is empty and the corresponding pop
is called, the entire concents of the other stack must be
transfered over. When that happens, the first stack is now empty
so calling the other pop will cause the entire stack to be
coppied over again. This process of copying the stack just to pop
one item will continue until the deque is empty and as long as
popback() and popfront() are called one after another, then the
entire deque will need to be coppied from one stack to another.


     
